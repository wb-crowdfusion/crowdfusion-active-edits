-- #############################
-- ########## WARNING ##########
-- #############################
--
-- RUN THIS WITHOUT PROPER AUTHORITY AND YOU'LL PROBABLY BE FIRED... OR WORSE. (0_0)
--
-- STEP 1: Run the migration cli on all `active-edits` records.
-- STEP 2: Verify data in repository is correct and check some records in CMS for legacy data.
-- STEP 3: Backup the database and store it with the date.
-- STEP 4: Move backup to s3 with filename different from the backup created automatically nightly.
-- STEP 5: Copy backup to offsite server.
-- STEP 6: Run this script.
--
-- This is for sites upgrading from 1.x branch to 2.x which moves storage for
-- history data from mysql to dynamodb.  This doesn't handle migration, only purging.
--
--
-- The example script below deletes all of the `active-edits` intags across all tables
-- and then drops the `active-edits` and transaction tables.
--
--
-- This should be the element id from system.xml for the "active-edits" element.
-- e.g. <element id="__THIS__VALUE__" pluginid="..." slug="active-edits">
-- Creates DELETE FROMs
-- <?php
--
-- $dbname         = '';
-- $dbhost         = '';
-- $dbuser         = '';
-- $dbpassword     = '';
-- $ElementID      = 9;
--
-- $db = new PDO('mysql:dbname=' . $dbname . ';host=' . $dbhost, $dbuser, $dbpassword);
-- $result = $db->query('show tables');
-- while ($row = $result->fetch(PDO::FETCH_NUM)) {
--   $table = $db->query(sprintf('select * from %s where ElementID = %d and Role = "active-edit-record" limit 1', $row[0], $ElementID));
--   if($table){
--     $found = $table->fetch(PDO::FETCH_NUM);
--     if ($found) {
--       echo sprintf("delete from %s where ElementID = %d and Role = 'active-edit-record';\n", $row[0], $ElementID);
--     }
--   }
-- }


DROP TABLE n_active_edit;
DROP TABLE n_active_edit_intags;
DROP TABLE n_active_edit_meta_tiny;
DROP TABLE n_active_edit_outtags;


-- for each element having the `@mixin-track-active-edits` aspect, delete the `active-edit-record` records
-- ONLY if the element id also matches, this is a safeguard to ensure no other tag roles might also be using
-- `active-edit-record`.

DELIMITER $$

DROP PROCEDURE IF EXISTS procPurgeAllTables $$
CREATE PROCEDURE procPurgeAllTables(elementID INT, Role VARCHAR(255))
BEGIN
  DECLARE tableName VARCHAR(255);
  DECLARE endOfTables TINYINT DEFAULT 0;

  DECLARE _cursor CURSOR FOR
    SELECT t.TABLE_NAME
    FROM information_schema.TABLES t  LEFT JOIN information_schema.COLUMNS c
      ON (t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA)
    WHERE t.TABLE_SCHEMA = DATABASE()
      AND t.TABLE_TYPE = 'BASE TABLE'
      AND (c.COLUMN_NAME = 'ElementId' OR c.COLUMN_NAME = 'Role')
    GROUP BY t.TABLE_NAME
    HAVING COUNT(1) = 2
    ORDER BY t.TABLE_NAME ASC;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET endOfTables = 1;

  OPEN _cursor;

  purgeTable: LOOP
    FETCH _cursor INTO tableName;

    IF endOfTables = 1 THEN
      LEAVE purgeTable;
    END IF;

    SET @minId = 0;
    SET @maxId = 0;

    SET @s = CONCAT('SELECT MIN(TagID) INTO @minId FROM ', tableName);
    PREPARE stmt FROM @s;
    EXECUTE stmt;

    SET @s = CONCAT('SELECT MAX(TagID) INTO @maxId FROM ', tableName);
    PREPARE stmt FROM @s;
    EXECUTE stmt;

    WHILE @minId <= @maxId DO

      #SET @s = CONCAT('DELETE FROM ', tableName, ' WHERE ElementID = ', elementID, ' AND Role = "', Role, '" AND TagID >= ', @minId, ' AND TagID <= ', (@minId + 10)');
      SET @s = CONCAT('SELECT "', tableName, '", COUNT(1) AS count FROM ' , tableName, ' WHERE TagID >= ', @minId, ' AND TagID <= ', (@minId + 10));
      PREPARE stmt FROM @s;
      EXECUTE stmt;

      SET @minId = @minId + 10;

      SELECT SLEEP(2);

    END WHILE;

  END LOOP;

  CLOSE _cursor;

END $$

DELIMITER ;

-- run: call procPurgeAllTables(9, 'active-edit-record');
